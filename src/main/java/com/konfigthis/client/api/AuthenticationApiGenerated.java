/*
 * Conjur
 * This is an API definition for CyberArk Conjur Open Source. You can find out more at [Conjur.org](https://www.conjur.org/).
 *
 * The version of the OpenAPI document: 5.3.1
 * Contact: conj_maintainers@cyberark.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AuthenticationAzureAuthenticateRequest;
import com.konfigthis.client.model.AuthenticationGcpAuthnAuthenticateRequest;
import com.konfigthis.client.model.AuthenticationJwtAuthenticateRequest;
import com.konfigthis.client.model.AuthenticationOidcAuthenticateRequest;
import com.konfigthis.client.model.AuthenticationToggleAuthenticatorStatusRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class AuthenticationApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AuthenticationApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public AuthenticationApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call authenticateWithIdCall(String account, String id, String serviceId, Object body, String xRequestId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn-jwt/{service_id}/{account}/{id}/authenticate"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call authenticateWithIdValidateBeforeCall(String account, String id, String serviceId, Object body, String xRequestId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling authenticateWithId(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling authenticateWithId(Async)");
        }

        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling authenticateWithId(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling authenticateWithId(Async)");
        }

        return authenticateWithIdCall(account, id, serviceId, body, xRequestId, _callback);

    }


    private ApiResponse<Void> authenticateWithIdWithHttpInfo(String account, String id, String serviceId, Object body, String xRequestId) throws ApiException {
        okhttp3.Call localVarCall = authenticateWithIdValidateBeforeCall(account, id, serviceId, body, xRequestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call authenticateWithIdAsync(String account, String id, String serviceId, Object body, String xRequestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = authenticateWithIdValidateBeforeCall(account, id, serviceId, body, xRequestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class AuthenticateWithIdRequestBuilder {
        private final String account;
        private final String id;
        private final String serviceId;
        private String xRequestId;
        private Object body;

        private AuthenticateWithIdRequestBuilder(String account, String id, String serviceId) {
            this.account = account;
            this.id = id;
            this.serviceId = serviceId;
        }

        /**
         * Set body
         * @param body ID token (optional)
         * @return AuthenticateWithIdRequestBuilder
         */
        public AuthenticateWithIdRequestBuilder body(Object body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return AuthenticateWithIdRequestBuilder
         */
        public AuthenticateWithIdRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Build call for authenticateWithId
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Object body = buildBodyParams();
            return authenticateWithIdCall(account, id, serviceId, body, xRequestId, _callback);
        }

        private Object buildBodyParams() {
            return this.body;
        }

        /**
         * Execute authenticateWithId request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            Object body = buildBodyParams();
            authenticateWithIdWithHttpInfo(account, id, serviceId, body, xRequestId);
        }

        /**
         * Execute authenticateWithId request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            Object body = buildBodyParams();
            return authenticateWithIdWithHttpInfo(account, id, serviceId, body, xRequestId);
        }

        /**
         * Execute authenticateWithId request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            Object body = buildBodyParams();
            return authenticateWithIdAsync(account, id, serviceId, body, xRequestId, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. Covers the case of use of optional URL parameter \&quot;ID\&quot; 
     * Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur. 
     * @param account Organization account name (required)
     * @param id Organization user id (required)
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param body ID token (required)
     * @return AuthenticateWithIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public AuthenticateWithIdRequestBuilder authenticateWithId(String account, String id, String serviceId) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            if (id != null && id.length() < 1) {
              throw new IllegalArgumentException("Invalid value for id. Length must be greater than or equal to 1.");
            }

        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        return new AuthenticateWithIdRequestBuilder(account, id, serviceId);
    }
    private okhttp3.Call azureAuthenticateCall(String serviceId, String account, ERRORUNKNOWN login, AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authenticationAzureAuthenticateRequest;

        // create path and map variables
        String localVarPath = "/authn-azure/{service_id}/{account}/{login}/authenticate"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "login" + "}", localVarApiClient.escapeString(login.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (jwt != null) {
            localVarFormParams.put("jwt", jwt);
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call azureAuthenticateValidateBeforeCall(String serviceId, String account, ERRORUNKNOWN login, AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling azureAuthenticate(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling azureAuthenticate(Async)");
        }

        // verify the required parameter 'login' is set
        if (login == null) {
            throw new ApiException("Missing the required parameter 'login' when calling azureAuthenticate(Async)");
        }

        // verify the required parameter 'authenticationAzureAuthenticateRequest' is set
        if (authenticationAzureAuthenticateRequest == null) {
            throw new ApiException("Missing the required parameter 'authenticationAzureAuthenticateRequest' when calling azureAuthenticate(Async)");
        }

        return azureAuthenticateCall(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);

    }


    private ApiResponse<Void> azureAuthenticateWithHttpInfo(String serviceId, String account, ERRORUNKNOWN login, AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt) throws ApiException {
        okhttp3.Call localVarCall = azureAuthenticateValidateBeforeCall(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call azureAuthenticateAsync(String serviceId, String account, ERRORUNKNOWN login, AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = azureAuthenticateValidateBeforeCall(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class AzureAuthenticateRequestBuilder {
        private final String serviceId;
        private final String account;
        private final ERRORUNKNOWN login;
        private String xRequestId;
        private String acceptEncoding;
        private String jwt;

        private AzureAuthenticateRequestBuilder(String serviceId, String account, ERRORUNKNOWN login) {
            this.serviceId = serviceId;
            this.account = account;
            this.login = login;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return AzureAuthenticateRequestBuilder
         */
        public AzureAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional, default to application/json)
         * @return AzureAuthenticateRequestBuilder
         */
        public AzureAuthenticateRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Set jwt
         * @param jwt  (optional)
         * @return AzureAuthenticateRequestBuilder
         */
        public AzureAuthenticateRequestBuilder jwt(String jwt) {
            this.jwt = jwt;
            return this;
        }
        
        /**
         * Build call for azureAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest = buildBodyParams();
            return azureAuthenticateCall(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        }

        private AuthenticationAzureAuthenticateRequest buildBodyParams() {
            AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest = new AuthenticationAzureAuthenticateRequest();
            authenticationAzureAuthenticateRequest.jwt(this.jwt);
            return authenticationAzureAuthenticateRequest;
        }

        /**
         * Execute azureAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest = buildBodyParams();
            azureAuthenticateWithHttpInfo(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt);
        }

        /**
         * Execute azureAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest = buildBodyParams();
            return azureAuthenticateWithHttpInfo(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt);
        }

        /**
         * Execute azureAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            AuthenticationAzureAuthenticateRequest authenticationAzureAuthenticateRequest = buildBodyParams();
            return azureAuthenticateAsync(serviceId, account, login, authenticationAzureAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications running in Azure.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as &#x60;Authorization: Token token&#x3D;&lt;base64-encoded token&gt;&#x60;.  The &#x60;login&#x60; must be URL encoded and the host ID must have the prefix &#x60;host/&#x60;. For example, the host webserver would login as &#x60;host/webserver&#x60;, and would be encoded as &#x60;host%2Fwebserver&#x60;.  The &#x60;service_id&#x60;, if given, must be URL encoded. For example, &#x60;prod/gke&#x60; must be encoded as &#x60;prod%2Fgke&#x60;.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Azure Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/azure_authn.htm) (&#x60;authn-azure&#x60;). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is &#x60;host/&lt;host-id&gt;&#x60; (required)
     * @param authenticationAzureAuthenticateRequest Azure identity token (required)
     * @return AzureAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public AzureAuthenticateRequestBuilder azureAuthenticate(String serviceId, String account, ERRORUNKNOWN login) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (login == null) throw new IllegalArgumentException("\"login\" is required but got null");
        return new AzureAuthenticateRequestBuilder(serviceId, account, login);
    }
    private okhttp3.Call changeUserPasswordCall(String account, String body, String xRequestId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn/{account}/password"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeUserPasswordValidateBeforeCall(String account, String body, String xRequestId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling changeUserPassword(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling changeUserPassword(Async)");
        }

        return changeUserPasswordCall(account, body, xRequestId, _callback);

    }


    private ApiResponse<Void> changeUserPasswordWithHttpInfo(String account, String body, String xRequestId) throws ApiException {
        okhttp3.Call localVarCall = changeUserPasswordValidateBeforeCall(account, body, xRequestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call changeUserPasswordAsync(String account, String body, String xRequestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = changeUserPasswordValidateBeforeCall(account, body, xRequestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ChangeUserPasswordRequestBuilder {
        private final String account;
        private String xRequestId;
        private String body;

        private ChangeUserPasswordRequestBuilder(String account) {
            this.account = account;
        }

        /**
         * Set body
         * @param body New password (optional)
         * @return ChangeUserPasswordRequestBuilder
         */
        public ChangeUserPasswordRequestBuilder body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return ChangeUserPasswordRequestBuilder
         */
        public ChangeUserPasswordRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Build call for changeUserPassword
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The password has been changed </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            String body = buildBodyParams();
            return changeUserPasswordCall(account, body, xRequestId, _callback);
        }

        private String buildBodyParams() {
            return this.body;
        }

        /**
         * Execute changeUserPassword request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The password has been changed </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            String body = buildBodyParams();
            changeUserPasswordWithHttpInfo(account, body, xRequestId);
        }

        /**
         * Execute changeUserPassword request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The password has been changed </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            String body = buildBodyParams();
            return changeUserPasswordWithHttpInfo(account, body, xRequestId);
        }

        /**
         * Execute changeUserPassword request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The password has been changed </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            String body = buildBodyParams();
            return changeUserPasswordAsync(account, body, xRequestId, _callback);
        }
    }

    /**
     * Changes a user’s password.
     * You must provide the login name and current password or API key of the user whose password is to be updated in an HTTP Basic Authentication header. Also replaces the user’s API key with a new securely generated random value. You can fetch the new API key using the Login method.  The Basic authentication-compliant header is formed by: 1. Concatenating the role&#39;s name, a literal colon character &#39;:&#39;,    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: &#x60;Basic &#x60;    (note the required space). 4. Providing the result as the value of the &#x60;Authorization&#x60; HTTP header:    &#x60;Authorization: Basic &lt;authentication string&gt;&#x60;.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, &#x60;curl&#x60; and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords. They authenticate using their API keys, while passwords are only used by human users. 
     * @param account Organization account name (required)
     * @param body New password (required)
     * @return ChangeUserPasswordRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The password has been changed </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public ChangeUserPasswordRequestBuilder changeUserPassword(String account) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        return new ChangeUserPasswordRequestBuilder(account);
    }
    private okhttp3.Call exchangeLdapCredentialsForApiKeyCall(String serviceId, String account, String xRequestId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/authn-ldap/{service_id}/{account}/login"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exchangeLdapCredentialsForApiKeyValidateBeforeCall(String serviceId, String account, String xRequestId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling exchangeLdapCredentialsForApiKey(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling exchangeLdapCredentialsForApiKey(Async)");
        }

        return exchangeLdapCredentialsForApiKeyCall(serviceId, account, xRequestId, _callback);

    }


    private ApiResponse<Void> exchangeLdapCredentialsForApiKeyWithHttpInfo(String serviceId, String account, String xRequestId) throws ApiException {
        okhttp3.Call localVarCall = exchangeLdapCredentialsForApiKeyValidateBeforeCall(serviceId, account, xRequestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call exchangeLdapCredentialsForApiKeyAsync(String serviceId, String account, String xRequestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = exchangeLdapCredentialsForApiKeyValidateBeforeCall(serviceId, account, xRequestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ExchangeLdapCredentialsForApiKeyRequestBuilder {
        private final String serviceId;
        private final String account;
        private String xRequestId;

        private ExchangeLdapCredentialsForApiKeyRequestBuilder(String serviceId, String account) {
            this.serviceId = serviceId;
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return ExchangeLdapCredentialsForApiKeyRequestBuilder
         */
        public ExchangeLdapCredentialsForApiKeyRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Build call for exchangeLdapCredentialsForApiKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return exchangeLdapCredentialsForApiKeyCall(serviceId, account, xRequestId, _callback);
        }


        /**
         * Execute exchangeLdapCredentialsForApiKey request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            exchangeLdapCredentialsForApiKeyWithHttpInfo(serviceId, account, xRequestId);
        }

        /**
         * Execute exchangeLdapCredentialsForApiKey request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return exchangeLdapCredentialsForApiKeyWithHttpInfo(serviceId, account, xRequestId);
        }

        /**
         * Execute exchangeLdapCredentialsForApiKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return exchangeLdapCredentialsForApiKeyAsync(serviceId, account, xRequestId, _callback);
        }
    }

    /**
     * Gets the Conjur API key of a user given the LDAP username and password via HTTP Basic Authentication. 
     * Exchange your LDAP credentials for a Conjur API key. Once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the LDAP username, a literal colon character &#39;:&#39;,    and the password to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: &#x60;Basic &#x60;    (note the required space). 4. Providing the result as the value of the &#x60;Authorization&#x60; HTTP header:    &#x60;Authorization: Basic &lt;authentication string&gt;&#x60;.  Your HTTP/REST client probably provides HTTP basic authentication support. 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @return ExchangeLdapCredentialsForApiKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public ExchangeLdapCredentialsForApiKeyRequestBuilder exchangeLdapCredentialsForApiKey(String serviceId, String account) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        return new ExchangeLdapCredentialsForApiKeyRequestBuilder(serviceId, account);
    }
    private okhttp3.Call gcpAuthnAuthenticateCall(String account, AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authenticationGcpAuthnAuthenticateRequest;

        // create path and map variables
        String localVarPath = "/authn-gcp/{account}/authenticate"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (jwt != null) {
            localVarFormParams.put("jwt", jwt);
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gcpAuthnAuthenticateValidateBeforeCall(String account, AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling gcpAuthnAuthenticate(Async)");
        }

        // verify the required parameter 'authenticationGcpAuthnAuthenticateRequest' is set
        if (authenticationGcpAuthnAuthenticateRequest == null) {
            throw new ApiException("Missing the required parameter 'authenticationGcpAuthnAuthenticateRequest' when calling gcpAuthnAuthenticate(Async)");
        }

        return gcpAuthnAuthenticateCall(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);

    }


    private ApiResponse<Void> gcpAuthnAuthenticateWithHttpInfo(String account, AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt) throws ApiException {
        okhttp3.Call localVarCall = gcpAuthnAuthenticateValidateBeforeCall(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call gcpAuthnAuthenticateAsync(String account, AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest, String xRequestId, String acceptEncoding, String jwt, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gcpAuthnAuthenticateValidateBeforeCall(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class GcpAuthnAuthenticateRequestBuilder {
        private final String account;
        private String xRequestId;
        private String acceptEncoding;
        private String jwt;

        private GcpAuthnAuthenticateRequestBuilder(String account) {
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return GcpAuthnAuthenticateRequestBuilder
         */
        public GcpAuthnAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional)
         * @return GcpAuthnAuthenticateRequestBuilder
         */
        public GcpAuthnAuthenticateRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Set jwt
         * @param jwt  (optional)
         * @return GcpAuthnAuthenticateRequestBuilder
         */
        public GcpAuthnAuthenticateRequestBuilder jwt(String jwt) {
            this.jwt = jwt;
            return this;
        }
        
        /**
         * Build call for gcpAuthnAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest = buildBodyParams();
            return gcpAuthnAuthenticateCall(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        }

        private AuthenticationGcpAuthnAuthenticateRequest buildBodyParams() {
            AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest = new AuthenticationGcpAuthnAuthenticateRequest();
            authenticationGcpAuthnAuthenticateRequest.jwt(this.jwt);
            return authenticationGcpAuthnAuthenticateRequest;
        }

        /**
         * Execute gcpAuthnAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest = buildBodyParams();
            gcpAuthnAuthenticateWithHttpInfo(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt);
        }

        /**
         * Execute gcpAuthnAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest = buildBodyParams();
            return gcpAuthnAuthenticateWithHttpInfo(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt);
        }

        /**
         * Execute gcpAuthnAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            AuthenticationGcpAuthnAuthenticateRequest authenticationGcpAuthnAuthenticateRequest = buildBodyParams();
            return gcpAuthnAuthenticateAsync(account, authenticationGcpAuthnAuthenticateRequest, xRequestId, acceptEncoding, jwt, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications running in Google Cloud Platform. 
     * Use the GCP Authenticator API to send an authentication request from a Google Cloud service to Conjur.  For more information, see [the documentation](https://docs.conjur.org/Latest/en/Content/Operations/Services/cjr-gcp-authn.htm). 
     * @param account Organization account name (required)
     * @param authenticationGcpAuthnAuthenticateRequest Google JWT identity token for the Google Cloud service (required)
     * @return GcpAuthnAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public GcpAuthnAuthenticateRequestBuilder gcpAuthnAuthenticate(String account) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            

        return new GcpAuthnAuthenticateRequestBuilder(account);
    }
    private okhttp3.Call getShortLivedTokenCall(String serviceId, String account, ERRORUNKNOWN login, String body, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn-iam/{service_id}/{account}/{login}/authenticate"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "login" + "}", localVarApiClient.escapeString(login.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getShortLivedTokenValidateBeforeCall(String serviceId, String account, ERRORUNKNOWN login, String body, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling getShortLivedToken(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling getShortLivedToken(Async)");
        }

        // verify the required parameter 'login' is set
        if (login == null) {
            throw new ApiException("Missing the required parameter 'login' when calling getShortLivedToken(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling getShortLivedToken(Async)");
        }

        return getShortLivedTokenCall(serviceId, account, login, body, xRequestId, acceptEncoding, _callback);

    }


    private ApiResponse<Void> getShortLivedTokenWithHttpInfo(String serviceId, String account, ERRORUNKNOWN login, String body, String xRequestId, String acceptEncoding) throws ApiException {
        okhttp3.Call localVarCall = getShortLivedTokenValidateBeforeCall(serviceId, account, login, body, xRequestId, acceptEncoding, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call getShortLivedTokenAsync(String serviceId, String account, ERRORUNKNOWN login, String body, String xRequestId, String acceptEncoding, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = getShortLivedTokenValidateBeforeCall(serviceId, account, login, body, xRequestId, acceptEncoding, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class GetShortLivedTokenRequestBuilder {
        private final String serviceId;
        private final String account;
        private final ERRORUNKNOWN login;
        private String xRequestId;
        private String acceptEncoding;
        private String body;

        private GetShortLivedTokenRequestBuilder(String serviceId, String account, ERRORUNKNOWN login) {
            this.serviceId = serviceId;
            this.account = account;
            this.login = login;
        }

        /**
         * Set body
         * @param body AWS Signature header (optional)
         * @return GetShortLivedTokenRequestBuilder
         */
        public GetShortLivedTokenRequestBuilder body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return GetShortLivedTokenRequestBuilder
         */
        public GetShortLivedTokenRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional, default to application/json)
         * @return GetShortLivedTokenRequestBuilder
         */
        public GetShortLivedTokenRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Build call for getShortLivedToken
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            String body = buildBodyParams();
            return getShortLivedTokenCall(serviceId, account, login, body, xRequestId, acceptEncoding, _callback);
        }

        private String buildBodyParams() {
            return this.body;
        }

        /**
         * Execute getShortLivedToken request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            String body = buildBodyParams();
            getShortLivedTokenWithHttpInfo(serviceId, account, login, body, xRequestId, acceptEncoding);
        }

        /**
         * Execute getShortLivedToken request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            String body = buildBodyParams();
            return getShortLivedTokenWithHttpInfo(serviceId, account, login, body, xRequestId, acceptEncoding);
        }

        /**
         * Execute getShortLivedToken request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            String body = buildBodyParams();
            return getShortLivedTokenAsync(serviceId, account, login, body, xRequestId, acceptEncoding, _callback);
        }
    }

    /**
     * Get a short-lived access token for applications running in AWS.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as &#x60;Authorization: Token token&#x3D;&lt;base64-encoded token&gt;&#x60;.  The &#x60;login&#x60; must be URL encoded and the host ID must have the prefix &#x60;host/&#x60;. For example, the host webserver would login as &#x60;host/webserver&#x60;, and would be encoded as &#x60;host%2Fwebserver&#x60;.  The &#x60;service_id&#x60;, if given, must be URL encoded. For example, &#x60;prod/gke&#x60; must be encoded as &#x60;prod%2Fgke&#x60;.  For detailed instructions on authenticating to Conjur using this endpoint, reference the documentation: [AWS IAM Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm) (&#x60;authn-iam&#x60;). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param login URL-encoded login name. For hosts, the login name is &#x60;host/&lt;host-id&gt;&#x60; (required)
     * @param body AWS Signature header (required)
     * @return GetShortLivedTokenRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public GetShortLivedTokenRequestBuilder getShortLivedToken(String serviceId, String account, ERRORUNKNOWN login) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (login == null) throw new IllegalArgumentException("\"login\" is required but got null");
        return new GetShortLivedTokenRequestBuilder(serviceId, account, login);
    }
    private okhttp3.Call getUserApiKeyCall(String account, String xRequestId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/authn/{account}/login"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
            "text/plain"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserApiKeyValidateBeforeCall(String account, String xRequestId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling getUserApiKey(Async)");
        }

        return getUserApiKeyCall(account, xRequestId, _callback);

    }


    private ApiResponse<Object> getUserApiKeyWithHttpInfo(String account, String xRequestId) throws ApiException {
        okhttp3.Call localVarCall = getUserApiKeyValidateBeforeCall(account, xRequestId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserApiKeyAsync(String account, String xRequestId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserApiKeyValidateBeforeCall(account, xRequestId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserApiKeyRequestBuilder {
        private final String account;
        private String xRequestId;

        private GetUserApiKeyRequestBuilder(String account) {
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return GetUserApiKeyRequestBuilder
         */
        public GetUserApiKeyRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Build call for getUserApiKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response body is the API key </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserApiKeyCall(account, xRequestId, _callback);
        }


        /**
         * Execute getUserApiKey request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response body is the API key </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getUserApiKeyWithHttpInfo(account, xRequestId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserApiKey request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response body is the API key </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getUserApiKeyWithHttpInfo(account, xRequestId);
        }

        /**
         * Execute getUserApiKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response body is the API key </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getUserApiKeyAsync(account, xRequestId, _callback);
        }
    }

    /**
     * Gets the API key of a user given the username and password via HTTP Basic Authentication. 
     * Passwords are stored in the Conjur database using &#x60;bcrypt&#x60; with a work factor of 12. Therefore, login is a fairly expensive operation. However, once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the role&#39;s name, a literal colon character &#39;:&#39;,    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: &#x60;Basic &#x60;    (note the required space). 4. Providing the result as the value of the &#x60;Authorization&#x60; HTTP header:    &#x60;Authorization: Basic &lt;authentication string&gt;&#x60;.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, &#x60;curl&#x60; and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords and do not need to use this endpoint. 
     * @param account Organization account name (required)
     * @return GetUserApiKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The response body is the API key </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public GetUserApiKeyRequestBuilder getUserApiKey(String account) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        return new GetUserApiKeyRequestBuilder(account);
    }
    private okhttp3.Call jwtAuthenticateCall(String account, String serviceId, AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest, String xRequestId, String jwt, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authenticationJwtAuthenticateRequest;

        // create path and map variables
        String localVarPath = "/authn-jwt/{service_id}/{account}/authenticate"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (jwt != null) {
            localVarFormParams.put("jwt", jwt);
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call jwtAuthenticateValidateBeforeCall(String account, String serviceId, AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest, String xRequestId, String jwt, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling jwtAuthenticate(Async)");
        }

        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling jwtAuthenticate(Async)");
        }

        // verify the required parameter 'authenticationJwtAuthenticateRequest' is set
        if (authenticationJwtAuthenticateRequest == null) {
            throw new ApiException("Missing the required parameter 'authenticationJwtAuthenticateRequest' when calling jwtAuthenticate(Async)");
        }

        return jwtAuthenticateCall(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt, _callback);

    }


    private ApiResponse<Void> jwtAuthenticateWithHttpInfo(String account, String serviceId, AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest, String xRequestId, String jwt) throws ApiException {
        okhttp3.Call localVarCall = jwtAuthenticateValidateBeforeCall(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call jwtAuthenticateAsync(String account, String serviceId, AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest, String xRequestId, String jwt, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = jwtAuthenticateValidateBeforeCall(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class JwtAuthenticateRequestBuilder {
        private final String account;
        private final String serviceId;
        private String xRequestId;
        private String jwt;

        private JwtAuthenticateRequestBuilder(String account, String serviceId) {
            this.account = account;
            this.serviceId = serviceId;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return JwtAuthenticateRequestBuilder
         */
        public JwtAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set jwt
         * @param jwt  (optional)
         * @return JwtAuthenticateRequestBuilder
         */
        public JwtAuthenticateRequestBuilder jwt(String jwt) {
            this.jwt = jwt;
            return this;
        }
        
        /**
         * Build call for jwtAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest = buildBodyParams();
            return jwtAuthenticateCall(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt, _callback);
        }

        private AuthenticationJwtAuthenticateRequest buildBodyParams() {
            AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest = new AuthenticationJwtAuthenticateRequest();
            authenticationJwtAuthenticateRequest.jwt(this.jwt);
            return authenticationJwtAuthenticateRequest;
        }

        /**
         * Execute jwtAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest = buildBodyParams();
            jwtAuthenticateWithHttpInfo(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt);
        }

        /**
         * Execute jwtAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest = buildBodyParams();
            return jwtAuthenticateWithHttpInfo(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt);
        }

        /**
         * Execute jwtAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            AuthenticationJwtAuthenticateRequest authenticationJwtAuthenticateRequest = buildBodyParams();
            return jwtAuthenticateAsync(account, serviceId, authenticationJwtAuthenticateRequest, xRequestId, jwt, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. 
     * Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur. 
     * @param account Organization account name (required)
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param authenticationJwtAuthenticateRequest ID token (required)
     * @return JwtAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public JwtAuthenticateRequestBuilder jwtAuthenticate(String account, String serviceId) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        return new JwtAuthenticateRequestBuilder(account, serviceId);
    }
    private okhttp3.Call kubernetesAuthnAuthenticateCall(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/authn-k8s/{service_id}/{account}/{login}/authenticate"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "login" + "}", localVarApiClient.escapeString(login.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call kubernetesAuthnAuthenticateValidateBeforeCall(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling kubernetesAuthnAuthenticate(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling kubernetesAuthnAuthenticate(Async)");
        }

        // verify the required parameter 'login' is set
        if (login == null) {
            throw new ApiException("Missing the required parameter 'login' when calling kubernetesAuthnAuthenticate(Async)");
        }

        return kubernetesAuthnAuthenticateCall(serviceId, account, login, xRequestId, acceptEncoding, _callback);

    }


    private ApiResponse<Void> kubernetesAuthnAuthenticateWithHttpInfo(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding) throws ApiException {
        okhttp3.Call localVarCall = kubernetesAuthnAuthenticateValidateBeforeCall(serviceId, account, login, xRequestId, acceptEncoding, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call kubernetesAuthnAuthenticateAsync(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = kubernetesAuthnAuthenticateValidateBeforeCall(serviceId, account, login, xRequestId, acceptEncoding, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class KubernetesAuthnAuthenticateRequestBuilder {
        private final String serviceId;
        private final String account;
        private final ERRORUNKNOWN login;
        private String xRequestId;
        private String acceptEncoding;

        private KubernetesAuthnAuthenticateRequestBuilder(String serviceId, String account, ERRORUNKNOWN login) {
            this.serviceId = serviceId;
            this.account = account;
            this.login = login;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return KubernetesAuthnAuthenticateRequestBuilder
         */
        public KubernetesAuthnAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional, default to application/json)
         * @return KubernetesAuthnAuthenticateRequestBuilder
         */
        public KubernetesAuthnAuthenticateRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Build call for kubernetesAuthnAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return kubernetesAuthnAuthenticateCall(serviceId, account, login, xRequestId, acceptEncoding, _callback);
        }


        /**
         * Execute kubernetesAuthnAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            kubernetesAuthnAuthenticateWithHttpInfo(serviceId, account, login, xRequestId, acceptEncoding);
        }

        /**
         * Execute kubernetesAuthnAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return kubernetesAuthnAuthenticateWithHttpInfo(serviceId, account, login, xRequestId, acceptEncoding);
        }

        /**
         * Execute kubernetesAuthnAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return kubernetesAuthnAuthenticateAsync(serviceId, account, login, xRequestId, acceptEncoding, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications running in Kubernetes.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as &#x60;Authorization: Token token&#x3D;&lt;base64-encoded token&gt;&#x60;.  The &#x60;login&#x60; must be URL encoded and the host ID must have the prefix &#x60;host/&#x60;. For example, the host webserver would login as &#x60;host/webserver&#x60;, and would be encoded as &#x60;host%2Fwebserver&#x60;.  The &#x60;service_id&#x60;, if given, must be URL encoded. For example, &#x60;prod/gke&#x60; must be encoded as &#x60;prod%2Fgke&#x60;.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Kubernetes Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/k8s_auth.htm) (&#x60;authn-k8s&#x60;). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is &#x60;host/&lt;host-id&gt;&#x60; (required)
     * @return KubernetesAuthnAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public KubernetesAuthnAuthenticateRequestBuilder kubernetesAuthnAuthenticate(String serviceId, String account, ERRORUNKNOWN login) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (login == null) throw new IllegalArgumentException("\"login\" is required but got null");
        return new KubernetesAuthnAuthenticateRequestBuilder(serviceId, account, login);
    }
    private okhttp3.Call ldapAuthenticateCall(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn-ldap/{service_id}/{account}/{login}/authenticate"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "login" + "}", localVarApiClient.escapeString(login.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call ldapAuthenticateValidateBeforeCall(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling ldapAuthenticate(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling ldapAuthenticate(Async)");
        }

        // verify the required parameter 'login' is set
        if (login == null) {
            throw new ApiException("Missing the required parameter 'login' when calling ldapAuthenticate(Async)");
        }

        return ldapAuthenticateCall(serviceId, account, login, xRequestId, acceptEncoding, body, _callback);

    }


    private ApiResponse<Void> ldapAuthenticateWithHttpInfo(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, Object body) throws ApiException {
        okhttp3.Call localVarCall = ldapAuthenticateValidateBeforeCall(serviceId, account, login, xRequestId, acceptEncoding, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call ldapAuthenticateAsync(String serviceId, String account, ERRORUNKNOWN login, String xRequestId, String acceptEncoding, Object body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = ldapAuthenticateValidateBeforeCall(serviceId, account, login, xRequestId, acceptEncoding, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class LdapAuthenticateRequestBuilder {
        private final String serviceId;
        private final String account;
        private final ERRORUNKNOWN login;
        private String xRequestId;
        private String acceptEncoding;
        private Object body;

        private LdapAuthenticateRequestBuilder(String serviceId, String account, ERRORUNKNOWN login) {
            this.serviceId = serviceId;
            this.account = account;
            this.login = login;
        }

        /**
         * Set body
         * @param body API key (optional)
         * @return LdapAuthenticateRequestBuilder
         */
        public LdapAuthenticateRequestBuilder body(Object body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return LdapAuthenticateRequestBuilder
         */
        public LdapAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional, default to application/json)
         * @return LdapAuthenticateRequestBuilder
         */
        public LdapAuthenticateRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Build call for ldapAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Object body = buildBodyParams();
            return ldapAuthenticateCall(serviceId, account, login, xRequestId, acceptEncoding, body, _callback);
        }

        private Object buildBodyParams() {
            return this.body;
        }

        /**
         * Execute ldapAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            Object body = buildBodyParams();
            ldapAuthenticateWithHttpInfo(serviceId, account, login, xRequestId, acceptEncoding, body);
        }

        /**
         * Execute ldapAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            Object body = buildBodyParams();
            return ldapAuthenticateWithHttpInfo(serviceId, account, login, xRequestId, acceptEncoding, body);
        }

        /**
         * Execute ldapAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            Object body = buildBodyParams();
            return ldapAuthenticateAsync(serviceId, account, login, xRequestId, acceptEncoding, body, _callback);
        }
    }

    /**
     * Gets a short-lived access token for users and hosts using their LDAP identity to access the Conjur API. 
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as &#x60;Authorization: Token token&#x3D;&lt;base64-encoded token&gt;&#x60;.  The &#x60;login&#x60; must be URL encoded. For example, &#x60;alice@devops&#x60; must be encoded as &#x60;alice%40devops&#x60;.  The &#x60;service_id&#x60;, if given, must be URL encoded. For example, &#x60;prod/gke&#x60; must be encoded as &#x60;prod%2Fgke&#x60;.  For host authentication, the &#x60;login&#x60; is the host ID with the prefix &#x60;host/&#x60;. For example, the host webserver would login as &#x60;host/webserver&#x60;, and would be encoded as &#x60;host%2Fwebserver&#x60;.  To authenticate to Conjur using a LDAP, reference the detailed documentation: [LDAP Authenticator](https://docs.conjur.org/Latest/en/Content/Integrations/ldap/ldap_authenticator.html) (&#x60;authn-ldap&#x60;). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is &#x60;host/&lt;host-id&gt;&#x60; (required)
     * @return LdapAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public LdapAuthenticateRequestBuilder ldapAuthenticate(String serviceId, String account, ERRORUNKNOWN login) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (login == null) throw new IllegalArgumentException("\"login\" is required but got null");
        return new LdapAuthenticateRequestBuilder(serviceId, account, login);
    }
    private okhttp3.Call obtainAccessTokenCall(String account, String login, String body, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn/{account}/{login}/authenticate"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()))
            .replace("{" + "login" + "}", localVarApiClient.escapeString(login.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (acceptEncoding != null) {
            localVarHeaderParams.put("Accept-Encoding", localVarApiClient.parameterToString(acceptEncoding));
        }

        final String[] localVarAccepts = {
            "text/plain"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call obtainAccessTokenValidateBeforeCall(String account, String login, String body, String xRequestId, String acceptEncoding, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling obtainAccessToken(Async)");
        }

        // verify the required parameter 'login' is set
        if (login == null) {
            throw new ApiException("Missing the required parameter 'login' when calling obtainAccessToken(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling obtainAccessToken(Async)");
        }

        return obtainAccessTokenCall(account, login, body, xRequestId, acceptEncoding, _callback);

    }


    private ApiResponse<String> obtainAccessTokenWithHttpInfo(String account, String login, String body, String xRequestId, String acceptEncoding) throws ApiException {
        okhttp3.Call localVarCall = obtainAccessTokenValidateBeforeCall(account, login, body, xRequestId, acceptEncoding, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call obtainAccessTokenAsync(String account, String login, String body, String xRequestId, String acceptEncoding, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = obtainAccessTokenValidateBeforeCall(account, login, body, xRequestId, acceptEncoding, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ObtainAccessTokenRequestBuilder {
        private final String account;
        private final String login;
        private String xRequestId;
        private String acceptEncoding;
        private String body;

        private ObtainAccessTokenRequestBuilder(String account, String login) {
            this.account = account;
            this.login = login;
        }

        /**
         * Set body
         * @param body API Key (optional)
         * @return ObtainAccessTokenRequestBuilder
         */
        public ObtainAccessTokenRequestBuilder body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return ObtainAccessTokenRequestBuilder
         */
        public ObtainAccessTokenRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set acceptEncoding
         * @param acceptEncoding Setting the Accept-Encoding header to base64 will return a pre-encoded access token (optional, default to application/json)
         * @return ObtainAccessTokenRequestBuilder
         */
        public ObtainAccessTokenRequestBuilder acceptEncoding(String acceptEncoding) {
            this.acceptEncoding = acceptEncoding;
            return this;
        }
        
        /**
         * Build call for obtainAccessToken
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response is an access token for conjur </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            String body = buildBodyParams();
            return obtainAccessTokenCall(account, login, body, xRequestId, acceptEncoding, _callback);
        }

        private String buildBodyParams() {
            return this.body;
        }

        /**
         * Execute obtainAccessToken request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response is an access token for conjur </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            String body = buildBodyParams();
            ApiResponse<String> localVarResp = obtainAccessTokenWithHttpInfo(account, login, body, xRequestId, acceptEncoding);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute obtainAccessToken request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response is an access token for conjur </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            String body = buildBodyParams();
            return obtainAccessTokenWithHttpInfo(account, login, body, xRequestId, acceptEncoding);
        }

        /**
         * Execute obtainAccessToken request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The response is an access token for conjur </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            String body = buildBodyParams();
            return obtainAccessTokenAsync(account, login, body, xRequestId, acceptEncoding, _callback);
        }
    }

    /**
     * Gets a short-lived access token, which is required in the header of most subsequent API requests. 
     * A client can obtain an access token by presenting a valid login name and API key.  The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  The &#x60;login&#x60; must be URL encoded. For example, &#x60;alice@devops&#x60; must be encoded as &#x60;alice%40devops&#x60;.  The &#x60;service_id&#x60;, if given, must be URL encoded. For example, &#x60;prod/gke&#x60; must be encoded as &#x60;prod%2Fgke&#x60;.  For host authentication, the &#x60;login&#x60; is the host ID with the prefix &#x60;host/&#x60;. For example, the host webserver would login as &#x60;host/webserver&#x60;, and would be encoded as &#x60;host%2Fwebserver&#x60;.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as &#x60;Authorization: Token token&#x3D;&lt;base64-encoded token&gt;&#x60;.  This is the default authentication endpoint only. See other endpoints for details on authenticating to Conjur using another method, e.g. for applications running in Azure or Kubernetes. 
     * @param account Organization account name (required)
     * @param login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is &#x60;host/&lt;host-id&gt;&#x60; (required)
     * @param body API Key (required)
     * @return ObtainAccessTokenRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The response is an access token for conjur </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public ObtainAccessTokenRequestBuilder obtainAccessToken(String account, String login) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        if (login == null) throw new IllegalArgumentException("\"login\" is required but got null");
            if (login != null && login.length() < 1) {
              throw new IllegalArgumentException("Invalid value for login. Length must be greater than or equal to 1.");
            }

        return new ObtainAccessTokenRequestBuilder(account, login);
    }
    private okhttp3.Call oidcAuthenticateCall(String serviceId, String account, AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest, String xRequestId, String idToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authenticationOidcAuthenticateRequest;

        // create path and map variables
        String localVarPath = "/authn-oidc/{service_id}/{account}/authenticate"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idToken != null) {
            localVarFormParams.put("id_token", idToken);
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call oidcAuthenticateValidateBeforeCall(String serviceId, String account, AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest, String xRequestId, String idToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling oidcAuthenticate(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling oidcAuthenticate(Async)");
        }

        // verify the required parameter 'authenticationOidcAuthenticateRequest' is set
        if (authenticationOidcAuthenticateRequest == null) {
            throw new ApiException("Missing the required parameter 'authenticationOidcAuthenticateRequest' when calling oidcAuthenticate(Async)");
        }

        return oidcAuthenticateCall(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken, _callback);

    }


    private ApiResponse<Void> oidcAuthenticateWithHttpInfo(String serviceId, String account, AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest, String xRequestId, String idToken) throws ApiException {
        okhttp3.Call localVarCall = oidcAuthenticateValidateBeforeCall(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call oidcAuthenticateAsync(String serviceId, String account, AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest, String xRequestId, String idToken, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = oidcAuthenticateValidateBeforeCall(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class OidcAuthenticateRequestBuilder {
        private final String serviceId;
        private final String account;
        private String xRequestId;
        private String idToken;

        private OidcAuthenticateRequestBuilder(String serviceId, String account) {
            this.serviceId = serviceId;
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return OidcAuthenticateRequestBuilder
         */
        public OidcAuthenticateRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set idToken
         * @param idToken  (optional)
         * @return OidcAuthenticateRequestBuilder
         */
        public OidcAuthenticateRequestBuilder idToken(String idToken) {
            this.idToken = idToken;
            return this;
        }
        
        /**
         * Build call for oidcAuthenticate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest = buildBodyParams();
            return oidcAuthenticateCall(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken, _callback);
        }

        private AuthenticationOidcAuthenticateRequest buildBodyParams() {
            AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest = new AuthenticationOidcAuthenticateRequest();
            authenticationOidcAuthenticateRequest.idToken(this.idToken);
            return authenticationOidcAuthenticateRequest;
        }

        /**
         * Execute oidcAuthenticate request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest = buildBodyParams();
            oidcAuthenticateWithHttpInfo(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken);
        }

        /**
         * Execute oidcAuthenticate request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest = buildBodyParams();
            return oidcAuthenticateWithHttpInfo(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken);
        }

        /**
         * Execute oidcAuthenticate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            AuthenticationOidcAuthenticateRequest authenticationOidcAuthenticateRequest = buildBodyParams();
            return oidcAuthenticateAsync(serviceId, account, authenticationOidcAuthenticateRequest, xRequestId, idToken, _callback);
        }
    }

    /**
     * Gets a short-lived access token for applications using OpenID Connect (OIDC) to access the Conjur API. 
     * Use the OIDC Authenticator to leverage the identity layer provided by OIDC to authenticate with Conjur.  For more information see [the documentation](https://docs.conjur.org/Latest/en/Content/OIDC/OIDC.htm). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param authenticationOidcAuthenticateRequest ID token (required)
     * @return OidcAuthenticateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
     </table>
     */
    public OidcAuthenticateRequestBuilder oidcAuthenticate(String serviceId, String account) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        return new OidcAuthenticateRequestBuilder(serviceId, account);
    }
    private okhttp3.Call rotateApiKeyCall(String account, String xRequestId, String role, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/authn/{account}/api_key"
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call rotateApiKeyValidateBeforeCall(String account, String xRequestId, String role, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling rotateApiKey(Async)");
        }

        return rotateApiKeyCall(account, xRequestId, role, _callback);

    }


    private ApiResponse<Void> rotateApiKeyWithHttpInfo(String account, String xRequestId, String role) throws ApiException {
        okhttp3.Call localVarCall = rotateApiKeyValidateBeforeCall(account, xRequestId, role, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call rotateApiKeyAsync(String account, String xRequestId, String role, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = rotateApiKeyValidateBeforeCall(account, xRequestId, role, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class RotateApiKeyRequestBuilder {
        private final String account;
        private String xRequestId;
        private String role;

        private RotateApiKeyRequestBuilder(String account) {
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return RotateApiKeyRequestBuilder
         */
        public RotateApiKeyRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set role
         * @param role (**Optional**) role specifier in &#x60;{kind}:{identifier}&#x60; format  ##### Permissions required  &#x60;update&#x60; privilege on the role whose API key is being rotated.  (optional)
         * @return RotateApiKeyRequestBuilder
         */
        public RotateApiKeyRequestBuilder role(String role) {
            this.role = role;
            return this;
        }
        
        /**
         * Build call for rotateApiKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return rotateApiKeyCall(account, xRequestId, role, _callback);
        }


        /**
         * Execute rotateApiKey request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            rotateApiKeyWithHttpInfo(account, xRequestId, role);
        }

        /**
         * Execute rotateApiKey request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return rotateApiKeyWithHttpInfo(account, xRequestId, role);
        }

        /**
         * Execute rotateApiKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return rotateApiKeyAsync(account, xRequestId, role, _callback);
        }
    }

    /**
     * Rotates a role&#39;s API key.
     * Any role can rotate its own API key. The name and password (for users) or current API key (for hosts and users) of the role must be provided via HTTP Basic Authorization.  To rotate another role&#39;s API key, you may provide your name and password (for users) or current API key (for hosts and users) via HTTP Basic Authorization with the request. Alternatively, you may provide your Conjur access token via the standard Conjur &#x60;Authorization&#x60; header.  The Basic authentication-compliant header is formed by: 1. Concatenating the role&#39;s name, a literal colon character &#39;:&#39;,    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: &#x60;Basic &#x60;    (note the required space). 4. Providing the result as the value of the &#x60;Authorization&#x60; HTTP header:    &#x60;Authorization: Basic &lt;authentication string&gt;&#x60;.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, &#x60;curl&#x60; and all of the Conjur client libraries provide this.  If using the Conjur &#x60;Authorization&#x60; header, its value should be set to &#x60;Token token&#x3D;&lt;base64-encoded access token&gt;&#x60;.  Note that the body of the request must be the empty string. 
     * @param account Organization account name (required)
     * @return RotateApiKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> A request parameter was either missing or invalid. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public RotateApiKeyRequestBuilder rotateApiKey(String account) throws IllegalArgumentException {
        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            if (account != null && account.length() < 1) {
              throw new IllegalArgumentException("Invalid value for account. Length must be greater than or equal to 1.");
            }

        return new RotateApiKeyRequestBuilder(account);
    }
    private okhttp3.Call sendCsrForClientCertInjectionCall(String serviceId, String body, String xRequestId, String hostIdPrefix, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/authn-k8s/{service_id}/inject_client_cert"
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        if (hostIdPrefix != null) {
            localVarHeaderParams.put("Host-Id-Prefix", localVarApiClient.parameterToString(hostIdPrefix));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendCsrForClientCertInjectionValidateBeforeCall(String serviceId, String body, String xRequestId, String hostIdPrefix, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling sendCsrForClientCertInjection(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling sendCsrForClientCertInjection(Async)");
        }

        return sendCsrForClientCertInjectionCall(serviceId, body, xRequestId, hostIdPrefix, _callback);

    }


    private ApiResponse<Void> sendCsrForClientCertInjectionWithHttpInfo(String serviceId, String body, String xRequestId, String hostIdPrefix) throws ApiException {
        okhttp3.Call localVarCall = sendCsrForClientCertInjectionValidateBeforeCall(serviceId, body, xRequestId, hostIdPrefix, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call sendCsrForClientCertInjectionAsync(String serviceId, String body, String xRequestId, String hostIdPrefix, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = sendCsrForClientCertInjectionValidateBeforeCall(serviceId, body, xRequestId, hostIdPrefix, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class SendCsrForClientCertInjectionRequestBuilder {
        private final String serviceId;
        private String xRequestId;
        private String hostIdPrefix;
        private String body;

        private SendCsrForClientCertInjectionRequestBuilder(String serviceId) {
            this.serviceId = serviceId;
        }

        /**
         * Set body
         * @param body Valid certificate signing request that includes the host identity suffix as the CSR common name  (optional)
         * @return SendCsrForClientCertInjectionRequestBuilder
         */
        public SendCsrForClientCertInjectionRequestBuilder body(String body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return SendCsrForClientCertInjectionRequestBuilder
         */
        public SendCsrForClientCertInjectionRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set hostIdPrefix
         * @param hostIdPrefix Dot-separated policy tree, prefixed by &#x60;host.&#x60;, where the application identity is defined (optional)
         * @return SendCsrForClientCertInjectionRequestBuilder
         */
        public SendCsrForClientCertInjectionRequestBuilder hostIdPrefix(String hostIdPrefix) {
            this.hostIdPrefix = hostIdPrefix;
            return this;
        }
        
        /**
         * Build call for sendCsrForClientCertInjection
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The injected certificate was accepted. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            String body = buildBodyParams();
            return sendCsrForClientCertInjectionCall(serviceId, body, xRequestId, hostIdPrefix, _callback);
        }

        private String buildBodyParams() {
            return this.body;
        }

        /**
         * Execute sendCsrForClientCertInjection request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The injected certificate was accepted. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            String body = buildBodyParams();
            sendCsrForClientCertInjectionWithHttpInfo(serviceId, body, xRequestId, hostIdPrefix);
        }

        /**
         * Execute sendCsrForClientCertInjection request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The injected certificate was accepted. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            String body = buildBodyParams();
            return sendCsrForClientCertInjectionWithHttpInfo(serviceId, body, xRequestId, hostIdPrefix);
        }

        /**
         * Execute sendCsrForClientCertInjection request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The injected certificate was accepted. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            String body = buildBodyParams();
            return sendCsrForClientCertInjectionAsync(serviceId, body, xRequestId, hostIdPrefix, _callback);
        }
    }

    /**
     * For applications running in Kubernetes; sends Conjur a certificate signing request (CSR) and requests a client certificate injected into the application&#39;s Kubernetes pod. 
     * This request sends a Certificate Signing Request to Conjur, which uses the Kubernetes API to inject a client certificate into the application pod.  This endpoint requires a properly configured Conjur Certificate Authority service alongside a properly configured and enabled Kubernetes authenticator. For detailed instructions, see [the documentation](https://docs.conjur.org/Latest/en/Content/Integrations/kubernetes.htm). 
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param body Valid certificate signing request that includes the host identity suffix as the CSR common name  (required)
     * @return SendCsrForClientCertInjectionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The injected certificate was accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
     </table>
     */
    public SendCsrForClientCertInjectionRequestBuilder sendCsrForClientCertInjection(String serviceId) throws IllegalArgumentException {
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        return new SendCsrForClientCertInjectionRequestBuilder(serviceId);
    }
    private okhttp3.Call toggleAuthenticatorInstanceStatusCall(ERRORUNKNOWN authenticator, String serviceId, String account, Object body, String xRequestId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/{authenticator}/{service_id}/{account}"
            .replace("{" + "authenticator" + "}", localVarApiClient.escapeString(authenticator.toString()))
            .replace("{" + "service_id" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call toggleAuthenticatorInstanceStatusValidateBeforeCall(ERRORUNKNOWN authenticator, String serviceId, String account, Object body, String xRequestId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticator' is set
        if (authenticator == null) {
            throw new ApiException("Missing the required parameter 'authenticator' when calling toggleAuthenticatorInstanceStatus(Async)");
        }

        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling toggleAuthenticatorInstanceStatus(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling toggleAuthenticatorInstanceStatus(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling toggleAuthenticatorInstanceStatus(Async)");
        }

        return toggleAuthenticatorInstanceStatusCall(authenticator, serviceId, account, body, xRequestId, _callback);

    }


    private ApiResponse<Void> toggleAuthenticatorInstanceStatusWithHttpInfo(ERRORUNKNOWN authenticator, String serviceId, String account, Object body, String xRequestId) throws ApiException {
        okhttp3.Call localVarCall = toggleAuthenticatorInstanceStatusValidateBeforeCall(authenticator, serviceId, account, body, xRequestId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call toggleAuthenticatorInstanceStatusAsync(ERRORUNKNOWN authenticator, String serviceId, String account, Object body, String xRequestId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = toggleAuthenticatorInstanceStatusValidateBeforeCall(authenticator, serviceId, account, body, xRequestId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ToggleAuthenticatorInstanceStatusRequestBuilder {
        private final ERRORUNKNOWN authenticator;
        private final String serviceId;
        private final String account;
        private String xRequestId;
        private Object body;

        private ToggleAuthenticatorInstanceStatusRequestBuilder(ERRORUNKNOWN authenticator, String serviceId, String account) {
            this.authenticator = authenticator;
            this.serviceId = serviceId;
            this.account = account;
        }

        /**
         * Set body
         * @param body Contains either &#x60;enabled&#x3D;true&#x60; or &#x60;enabled&#x3D;false&#x60; to enable or disable an authenticator  (optional)
         * @return ToggleAuthenticatorInstanceStatusRequestBuilder
         */
        public ToggleAuthenticatorInstanceStatusRequestBuilder body(Object body) {
            this.body = body;
            return this;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return ToggleAuthenticatorInstanceStatusRequestBuilder
         */
        public ToggleAuthenticatorInstanceStatusRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Build call for toggleAuthenticatorInstanceStatus
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Object body = buildBodyParams();
            return toggleAuthenticatorInstanceStatusCall(authenticator, serviceId, account, body, xRequestId, _callback);
        }

        private Object buildBodyParams() {
            return this.body;
        }

        /**
         * Execute toggleAuthenticatorInstanceStatus request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            Object body = buildBodyParams();
            toggleAuthenticatorInstanceStatusWithHttpInfo(authenticator, serviceId, account, body, xRequestId);
        }

        /**
         * Execute toggleAuthenticatorInstanceStatus request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            Object body = buildBodyParams();
            return toggleAuthenticatorInstanceStatusWithHttpInfo(authenticator, serviceId, account, body, xRequestId);
        }

        /**
         * Execute toggleAuthenticatorInstanceStatus request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            Object body = buildBodyParams();
            return toggleAuthenticatorInstanceStatusAsync(authenticator, serviceId, account, body, xRequestId, _callback);
        }
    }

    /**
     * Enables or disables authenticator service instances.
     * Allows you to either enable or disable a given authenticator service instance.  When you enable or disable an authenticator service instance via this endpoint, the status of the authenticator service instance is stored in the Conjur database. The enablement status of the authenticator service instance may be overridden by setting the &#x60;CONJUR_AUTHENTICATORS&#x60; environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service instance is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.** 
     * @param authenticator The authenticator to update (required)
     * @param serviceId URL-Encoded authenticator service ID (required)
     * @param account Organization account name (required)
     * @param body Contains either &#x60;enabled&#x3D;true&#x60; or &#x60;enabled&#x3D;false&#x60; to enable or disable an authenticator  (required)
     * @return ToggleAuthenticatorInstanceStatusRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public ToggleAuthenticatorInstanceStatusRequestBuilder toggleAuthenticatorInstanceStatus(ERRORUNKNOWN authenticator, String serviceId, String account) throws IllegalArgumentException {
        if (authenticator == null) throw new IllegalArgumentException("\"authenticator\" is required but got null");
        if (serviceId == null) throw new IllegalArgumentException("\"serviceId\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            

        return new ToggleAuthenticatorInstanceStatusRequestBuilder(authenticator, serviceId, account);
    }
    private okhttp3.Call toggleAuthenticatorStatusCall(String authenticator, String account, AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest, String xRequestId, Boolean enabled, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = authenticationToggleAuthenticatorStatusRequest;

        // create path and map variables
        String localVarPath = "/{authenticator}/{account}"
            .replace("{" + "authenticator" + "}", localVarApiClient.escapeString(authenticator.toString()))
            .replace("{" + "account" + "}", localVarApiClient.escapeString(account.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (enabled != null) {
            localVarFormParams.put("enabled", enabled);
        }

        if (xRequestId != null) {
            localVarHeaderParams.put("X-Request-Id", localVarApiClient.parameterToString(xRequestId));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth", "conjurAuth", "conjurKubernetesMutualTls" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call toggleAuthenticatorStatusValidateBeforeCall(String authenticator, String account, AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest, String xRequestId, Boolean enabled, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authenticator' is set
        if (authenticator == null) {
            throw new ApiException("Missing the required parameter 'authenticator' when calling toggleAuthenticatorStatus(Async)");
        }

        // verify the required parameter 'account' is set
        if (account == null) {
            throw new ApiException("Missing the required parameter 'account' when calling toggleAuthenticatorStatus(Async)");
        }

        // verify the required parameter 'authenticationToggleAuthenticatorStatusRequest' is set
        if (authenticationToggleAuthenticatorStatusRequest == null) {
            throw new ApiException("Missing the required parameter 'authenticationToggleAuthenticatorStatusRequest' when calling toggleAuthenticatorStatus(Async)");
        }

        return toggleAuthenticatorStatusCall(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled, _callback);

    }


    private ApiResponse<Void> toggleAuthenticatorStatusWithHttpInfo(String authenticator, String account, AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest, String xRequestId, Boolean enabled) throws ApiException {
        okhttp3.Call localVarCall = toggleAuthenticatorStatusValidateBeforeCall(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call toggleAuthenticatorStatusAsync(String authenticator, String account, AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest, String xRequestId, Boolean enabled, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = toggleAuthenticatorStatusValidateBeforeCall(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ToggleAuthenticatorStatusRequestBuilder {
        private final String authenticator;
        private final String account;
        private String xRequestId;
        private Boolean enabled;

        private ToggleAuthenticatorStatusRequestBuilder(String authenticator, String account) {
            this.authenticator = authenticator;
            this.account = account;
        }

        /**
         * Set xRequestId
         * @param xRequestId Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one.  (optional)
         * @return ToggleAuthenticatorStatusRequestBuilder
         */
        public ToggleAuthenticatorStatusRequestBuilder xRequestId(String xRequestId) {
            this.xRequestId = xRequestId;
            return this;
        }
        
        /**
         * Set enabled
         * @param enabled  (optional)
         * @return ToggleAuthenticatorStatusRequestBuilder
         */
        public ToggleAuthenticatorStatusRequestBuilder enabled(Boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        /**
         * Build call for toggleAuthenticatorStatus
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest = buildBodyParams();
            return toggleAuthenticatorStatusCall(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled, _callback);
        }

        private AuthenticationToggleAuthenticatorStatusRequest buildBodyParams() {
            AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest = new AuthenticationToggleAuthenticatorStatusRequest();
            authenticationToggleAuthenticatorStatusRequest.enabled(this.enabled);
            return authenticationToggleAuthenticatorStatusRequest;
        }

        /**
         * Execute toggleAuthenticatorStatus request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest = buildBodyParams();
            toggleAuthenticatorStatusWithHttpInfo(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled);
        }

        /**
         * Execute toggleAuthenticatorStatus request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest = buildBodyParams();
            return toggleAuthenticatorStatusWithHttpInfo(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled);
        }

        /**
         * Execute toggleAuthenticatorStatus request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            AuthenticationToggleAuthenticatorStatusRequest authenticationToggleAuthenticatorStatusRequest = buildBodyParams();
            return toggleAuthenticatorStatusAsync(authenticator, account, authenticationToggleAuthenticatorStatusRequest, xRequestId, enabled, _callback);
        }
    }

    /**
     * Enables or disables authenticator defined without service_id.
     * Allows you to either enable or disable a given authenticator that does not have service_id (For example: authn-gcp).  When you enable or disable an authenticator via this endpoint, the status of the authenticator is stored in the Conjur database. The enablement status of the authenticator service may be overridden by setting the &#x60;CONJUR_AUTHENTICATORS&#x60; environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.** 
     * @param authenticator The authenticator to update (required)
     * @param account Organization account name (required)
     * @param authenticationToggleAuthenticatorStatusRequest Contains either &#x60;enabled&#x3D;true&#x60; or &#x60;enabled&#x3D;false&#x60; to enable or disable an authenticator  (required)
     * @return ToggleAuthenticatorStatusRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The config was updated properly </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The server cannot process the request due to malformed request syntax </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication information is missing or invalid </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The requested resource does not exist, the authenticated user lacks the required privileges to enumerate this resource, or its value has not been set </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Malfromed request, rejected by the server </td><td>  -  </td></tr>
     </table>
     */
    public ToggleAuthenticatorStatusRequestBuilder toggleAuthenticatorStatus(String authenticator, String account) throws IllegalArgumentException {
        if (authenticator == null) throw new IllegalArgumentException("\"authenticator\" is required but got null");
            

        if (account == null) throw new IllegalArgumentException("\"account\" is required but got null");
            

        return new ToggleAuthenticatorStatusRequestBuilder(authenticator, account);
    }
}
